<!DOCTYPE html>
<html lang="bn">
  <head>
    <meta charset="UTF-8" />
    <title>React Demo - Function Component Support</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      // --- Element creation (JSX support) ---
      function createElement(type, props, ...children) {
        return {
          type,
          props: {
            ...props,
            children: children.map(child =>
              typeof child === "object" ? child : createTextElement(child)
            ),
          },
        };
      }

      function createTextElement(text) {
        return {
          type: "TEXT_ELEMENT",
          props: {
            nodeValue: text,
            children: [],
          },
        };
      }

      // --- DOM creation & update helpers ---
      function createDom(fiber) {
        const dom =
          fiber.type === "TEXT_ELEMENT"
            ? document.createTextNode(fiber.props.nodeValue)
            : document.createElement(fiber.type);

        updateDom(dom, {}, fiber.props);
        return dom;
      }

      function isEvent(key) {
        return key.startsWith("on");
      }

      function isProperty(key) {
        return key !== "children" && !isEvent(key);
      }

      function updateDom(dom, prevProps, nextProps) {
        // Remove old or changed event listeners
        Object.keys(prevProps)
          .filter(isEvent)
          .forEach(name => {
            const eventType = name.toLowerCase().substring(2);
            if (!nextProps[name] || prevProps[name] !== nextProps[name]) {
              dom.removeEventListener(eventType, prevProps[name]);
            }
          });

        // Remove old properties
        Object.keys(prevProps)
          .filter(isProperty)
          .forEach(name => {
            if (!(name in nextProps)) {
              dom[name] = "";
            }
          });

        // Set new or changed properties
        Object.keys(nextProps)
          .filter(isProperty)
          .forEach(name => {
            if (prevProps[name] !== nextProps[name]) {
              dom[name] = nextProps[name];
            }
          });

        // Add new event listeners
        Object.keys(nextProps)
          .filter(isEvent)
          .forEach(name => {
            const eventType = name.toLowerCase().substring(2);
            if (prevProps[name] !== nextProps[name]) {
              dom.addEventListener(eventType, nextProps[name]);
            }
          });
      }

      // --- Fiber & scheduling globals ---
      let nextUnitOfWork = null;
      let wipRoot = null;
      let currentRoot = null;
      let deletions = [];

      // --- render entrypoint ---
      function render(element, container) {
        wipRoot = {
          dom: container,
          props: { children: [element] },
          alternate: currentRoot,
        };
        deletions = [];
        nextUnitOfWork = wipRoot;
      }

      // --- commit phase ---
      function commitRoot() {
        deletions.forEach(commitDeletion);
        commitWork(wipRoot.child);
        currentRoot = wipRoot;
        wipRoot = null;
      }

      function commitWork(fiber) {
        if (!fiber) return;

        // Find nearest parent with a DOM node
        let domParentFiber = fiber.parent;
        while (!domParentFiber.dom) {
          domParentFiber = domParentFiber.parent;
        }
        const domParent = domParentFiber.dom;

        if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {
          domParent.appendChild(fiber.dom);
        } else if (fiber.effectTag === "DELETION") {
          commitDeletion(fiber, domParent);
          return;
        } else if (fiber.effectTag === "UPDATE" && fiber.dom != null) {
          updateDom(
            fiber.dom,
            fiber.alternate ? fiber.alternate.props : {},
            fiber.props
          );
        }

        commitWork(fiber.child);
        commitWork(fiber.sibling);
      }

      function commitDeletion(fiber, domParent) {
        if (fiber.dom) {
          domParent.removeChild(fiber.dom);
        } else if (fiber.child) {
          commitDeletion(fiber.child, domParent);
        }
      }

      // --- work loop (idle callback) ---
      function workLoop(deadline) {
        let shouldYield = false;
        while (nextUnitOfWork && !shouldYield) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          shouldYield = deadline.timeRemaining() < 1;
        }

        if (!nextUnitOfWork && wipRoot) {
          commitRoot();
        }

        requestIdleCallback(workLoop);
      }
      requestIdleCallback(workLoop);

      // --- performUnitOfWork ---
      function performUnitOfWork(fiber) {
        const isFunctionalComponent = fiber.type instanceof Function;

        if (isFunctionalComponent) {
          updateFunctionalComponent(fiber);
        } else {
          updateHostComponent(fiber);
        }

        // Traverse fiber tree (DFS order)
        if (fiber.child) {
          return fiber.child;
        }

        let nextFiber = fiber;
        while (nextFiber) {
          if (nextFiber.sibling) {
            return nextFiber.sibling;
          }
          nextFiber = nextFiber.parent;
        }
        return null;
      }

      // --- Component update helpers ---
      function updateFunctionalComponent(fiber) {
        const children = [fiber.type(fiber.props)];
        reconcileChildren(fiber, children);
      }

      function updateHostComponent(fiber) {
        if (!fiber.dom) {
          fiber.dom = createDom(fiber);
        }
        reconcileChildren(fiber, fiber.props.children);
      }

      // --- reconciliation ---
      function reconcileChildren(wipFiber, elements) {
        let index = 0;
        let oldFiber = wipFiber.alternate && wipFiber.alternate.child;
        let prevSibling = null;

        while (index < elements.length || oldFiber != null) {
          const element = elements[index];
          let newFiber = null;

          const sameType =
            oldFiber && element && element.type === oldFiber.type;

          if (sameType) {
            newFiber = {
              type: oldFiber.type,
              props: element.props,
              dom: oldFiber.dom,
              parent: wipFiber,
              alternate: oldFiber,
              effectTag: "UPDATE",
            };
          } else if (element && !sameType) {
            newFiber = {
              type: element.type,
              props: element.props,
              dom: null,
              parent: wipFiber,
              alternate: null,
              effectTag: "PLACEMENT",
            };
          }

          if (oldFiber && !sameType) {
            oldFiber.effectTag = "DELETION";
            deletions.push(oldFiber);
          }

          if (oldFiber) {
            oldFiber = oldFiber.sibling;
          }

          if (index === 0) {
            wipFiber.child = newFiber;
          } else if (element) {
            prevSibling.sibling = newFiber;
          }

          prevSibling = newFiber;
          index++;
        }
      }

      // --- public API ---
      const Navid = {
        createElement,
        render,
      };

      /** @jsx Navid.createElement */
      function App(props) {
        return <h1>Hi {props.name}</h1>;
      }

      const element = <App name="Foo" />;
      const container = document.getElementById("root");
      Navid.render(element, container);
    </script>
  </body>
</html>
